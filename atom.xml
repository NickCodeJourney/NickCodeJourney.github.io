<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nick&#39;s Blog</title>
  
  
  <link href="https://nickcodejourney.github.io/atom.xml" rel="self"/>
  
  <link href="https://nickcodejourney.github.io/"/>
  <updated>2024-12-17T09:26:49.949Z</updated>
  <id>https://nickcodejourney.github.io/</id>
  
  <author>
    <name>Nick</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx解决跨域问题</title>
    <link href="https://nickcodejourney.github.io/2024/12/17/nginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://nickcodejourney.github.io/2024/12/17/nginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2024-12-17T09:23:01.000Z</published>
    <updated>2024-12-17T09:26:49.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、什么是跨域"><a href="#1、什么是跨域" class="headerlink" title="1、什么是跨域"></a>1、什么是跨域</h2><p>跨域是指一个域名下的资源去访问另一个域名下的资源。</p><h2 id="2、什么是同源策略"><a href="#2、什么是同源策略" class="headerlink" title="2、什么是同源策略"></a>2、什么是同源策略</h2><p>同源策略是浏览器的一种安全机制，它要求发送请求的URL与服务器返回的URL必须具有相同的协议、主机和端口。</p><h2 id="3、如何解决跨域问题"><a href="#3、如何解决跨域问题" class="headerlink" title="3、如何解决跨域问题"></a>3、如何解决跨域问题</h2><p>通过 Nginx 反向代理可以解决跨域问题，通常涉及设置 CORS 相关的响应头。以下是一个典型的 Nginx 配置示例：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /myProject/api/ {</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 支持跨域的预检请求（OPTIONS 请求）</span></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">'OPTIONS'</span>) {</span><br><span class="line">        <span class="attribute">return</span> <span class="number">204</span>;  <span class="comment"># 直接返回 204 No Content 作为响应</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 允许的跨域 Origin 设置为请求头中的 Origin</span></span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">"<span class="variable">$http_origin</span>"</span> always;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置跨域请求头</span></span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'false'</span> always;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 支持的请求方法</span></span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span> always;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 支持的请求头</span></span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">'Access-Control-Allow-Headers'</span> <span class="string">'Authorization, Content-Type'</span> always;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 继续代理请求</span></span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:9001;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果没有 Origin 头部，视为同源请求，允许通过</span></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$http_origin</span> = <span class="string">""</span>) {</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果请求头中有 Origin，且不在白名单内，则返回 403</span></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$http_origin</span> !<span class="regexp">~* "(http://www.test.com|http://10.14.32.138)")</span> {</span><br><span class="line">        <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><ul><li><code>Access-Control-Allow-Origin</code>: 允许指定的域名进行跨域访问。通常通过 <code>$http_origin</code> 来动态获取请求头中的 <code>Origin</code>，或者直接指定具体的域名（如<code>http://www.test.com</code>）。</li><li><code>Access-Control-Allow-Credentials</code>: 设置为 <code>false</code> 时，不允许发送 cookies 等凭证信息。</li><li><code>Access-Control-Allow-Methods</code>: 指定允许的 HTTP 方法，如 <code>GET</code>, <code>POST</code>, <code>OPTIONS</code>。</li><li><code>Access-Control-Allow-Headers</code>: 指定允许的请求头，通常包括 <code>Authorization</code>, <code>Content-Type</code> 等常见头信息。</li></ul><h2 id="4、跨域常见场景"><a href="#4、跨域常见场景" class="headerlink" title="4、跨域常见场景"></a>4、跨域常见场景</h2><h3 id="4-1-不同域名"><a href="#4-1-不同域名" class="headerlink" title="4.1 不同域名"></a>4.1 不同域名</h3><ul><li>example.com 访问 api.example.com</li><li>a.com 访问 b.com</li></ul><h3 id="4-2-不同端口"><a href="#4-2-不同端口" class="headerlink" title="4.2 不同端口"></a>4.2 不同端口</h3><ul><li>localhost:8080 访问 localhost:3000</li></ul><h3 id="4-3-不同协议"><a href="#4-3-不同协议" class="headerlink" title="4.3 不同协议"></a>4.3 不同协议</h3><ul><li><p><a href="https://example.com/">https://example.com</a> 访问 <a href="http://example.com/">http://example.com</a></p><h2 id="5、其他跨域解决方案"><a href="#5、其他跨域解决方案" class="headerlink" title="5、其他跨域解决方案"></a>5、其他跨域解决方案</h2></li></ul><h3 id="5-1-CORS（跨域资源共享）"><a href="#5-1-CORS（跨域资源共享）" class="headerlink" title="5.1 CORS（跨域资源共享）"></a>5.1 CORS（跨域资源共享）</h3><p>CORS（Cross-Origin Resource Sharing）是一种允许浏览器向跨源服务器发出请求的机制。除了在 Nginx 中配置跨域，还可以在后端应用中设置 CORS 响应头，以控制跨域请求。</p><p>例如，在一个 Node.js 应用中，可以使用如下代码：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> {</span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>); <span class="comment">// 允许所有域名访问</span></span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"GET, POST, PUT, DELETE, OPTIONS"</span>);</span><br><span class="line">  res.<span class="title function_">header</span>(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Origin, Content-Type, Accept, Authorization"</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">'/api/data'</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> {</span><br><span class="line">  res.<span class="title function_">json</span>({ <span class="attr">message</span>: <span class="string">"Hello, world!"</span> });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">"Server is running on port 3000"</span>));</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，CORS 头部通过 <code>res.header()</code> 设置，允许所有域名（<code>*</code>）进行跨域访问，支持 <code>GET</code>, <code>POST</code>, <code>PUT</code> 等 HTTP 方法，并指定允许的请求头。</p><h3 id="5-2-JSONP（JSON-with-Padding）"><a href="#5-2-JSONP（JSON-with-Padding）" class="headerlink" title="5.2 JSONP（JSON with Padding）"></a>5.2 JSONP（JSON with Padding）</h3><p>JSONP 是一种通过 <code>&lt;script&gt;</code> 标签来绕过同源策略进行跨域请求的方法。它的原理是利用 <code>&lt;script&gt;</code> 标签可以跨域加载 JavaScript 资源的特点，通过回调函数的方式返回数据。JSONP 只支持 <code>GET</code> 请求。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">handleResponse</span>(<span class="params">data</span>) {</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span><br><span class="line"><span class="language-javascript">  }</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="language-javascript">  script.<span class="property">src</span> = <span class="string">'http://example.com/api?callback=handleResponse'</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-3-WebSocket"><a href="#5-3-WebSocket" class="headerlink" title="5.3 WebSocket"></a>5.3 WebSocket</h3><p>WebSocket 允许在浏览器与服务器之间建立持久化的双向连接，这使得 WebSocket 成为一种天然的跨域解决方案。通过 WebSocket 协议，浏览器与不同域的服务器之间可以实时通信，且不受同源策略的限制。</p><h3 id="5-4-后端代理"><a href="#5-4-后端代理" class="headerlink" title="5.4 后端代理"></a>5.4 后端代理</h3><p>通过配置服务器端反向代理，将跨域请求转发到目标服务器。Nginx 和其他反向代理服务器可以帮助解决跨域问题。例如：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /api/ {</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://api.example.com;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这个例子中，Nginx 会将 <code>/api/</code> 开头的请求转发到 <code>http://api.example.com</code>，避免了跨域问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、什么是跨域&quot;&gt;&lt;a href=&quot;#1、什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;1、什么是跨域&quot;&gt;&lt;/a&gt;1、什么是跨域&lt;/h2&gt;&lt;p&gt;跨域是指一个域名下的资源去访问另一个域名下的资源。&lt;/p&gt;
&lt;h2 id=&quot;2、什么是同源策略&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="nginx" scheme="https://nickcodejourney.github.io/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://nickcodejourney.github.io/tags/nginx/"/>
    
    <category term="反向代理" scheme="https://nickcodejourney.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
    <category term="跨域" scheme="https://nickcodejourney.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Docker镜像架构问题</title>
    <link href="https://nickcodejourney.github.io/2024/12/17/Docker%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98/"/>
    <id>https://nickcodejourney.github.io/2024/12/17/Docker%E6%9E%B6%E6%9E%84%E9%97%AE%E9%A2%98/</id>
    <published>2024-12-17T07:00:00.000Z</published>
    <updated>2024-12-17T07:08:41.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-架构基础"><a href="#Docker-架构基础" class="headerlink" title="Docker 架构基础"></a>Docker 架构基础</h2><h3 id="1-x86架构的Docker镜像可以运行在arm架构的机器上吗？"><a href="#1-x86架构的Docker镜像可以运行在arm架构的机器上吗？" class="headerlink" title="1. x86架构的Docker镜像可以运行在arm架构的机器上吗？"></a>1. x86架构的Docker镜像可以运行在arm架构的机器上吗？</h3><ul><li>默认情况下，x86架构的Docker镜像不能直接运行在arm架构的机器上</li><li>但可以通过以下方式实现跨架构运行：<ol><li>使用 QEMU 模拟器</li><li>使用支持多架构的镜像（multi-arch images）</li><li>使用 buildx 构建多架构镜像</li></ol></li></ul><h3 id="2-Docker-镜像架构类型"><a href="#2-Docker-镜像架构类型" class="headerlink" title="2. Docker 镜像架构类型"></a>2. Docker 镜像架构类型</h3><p>常见的 Docker 镜像架构包括：</p><ul><li>linux/amd64 (x86_64)</li><li>linux/arm64 (aarch64)</li><li>linux/arm/v7</li><li>linux/arm/v6</li><li>linux/386</li><li>linux/ppc64le</li><li>linux/s390x</li></ul><h3 id="3-多架构镜像（Multi-arch-images）"><a href="#3-多架构镜像（Multi-arch-images）" class="headerlink" title="3. 多架构镜像（Multi-arch images）"></a>3. 多架构镜像（Multi-arch images）</h3><p>多架构镜像允许同一个镜像标签支持多个平台和架构：</p><ul><li>Docker 会自动选择匹配当前系统架构的版本</li><li>无需手动指定架构参数</li><li>通过 manifest 列表实现</li></ul><h3 id="4-Docker镜像架构查看方法"><a href="#4-Docker镜像架构查看方法" class="headerlink" title="4. Docker镜像架构查看方法"></a>4. Docker镜像架构查看方法</h3><p>查看镜像架构的几种方式：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：使用 docker inspect</span></span><br><span class="line">docker inspect image_name | grep <span class="string">"Architecture"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2：查看镜像清单</span></span><br><span class="line">docker manifest inspect image_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法3：使用 docker info</span></span><br><span class="line">docker info | grep <span class="string">"Architecture"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-构建特定架构的镜像"><a href="#5-构建特定架构的镜像" class="headerlink" title="5. 构建特定架构的镜像"></a>5. 构建特定架构的镜像</h3><p>使用 <code>--platform</code> 参数指定目标架构：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建 ARM64 架构镜像</span></span><br><span class="line">docker build --platform=linux/arm64 -t myimage:arm64 .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 AMD64 架构镜像</span></span><br><span class="line">docker build --platform=linux/amd64 -t myimage:amd64 .</span><br></pre></td></tr></tbody></table></figure><h3 id="6-拉取特定架构的镜像"><a href="#6-拉取特定架构的镜像" class="headerlink" title="6. 拉取特定架构的镜像"></a>6. 拉取特定架构的镜像</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取 ARM64 架构镜像</span></span><br><span class="line">docker pull --platform=linux/arm64 nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取 AMD64 架构镜像</span></span><br><span class="line">docker pull --platform=linux/amd64 nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置默认架构</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_DEFAULT_PLATFORM=linux/amd64</span><br></pre></td></tr></tbody></table></figure><h3 id="7-ARM-Mac-运行-x86-架构镜像"><a href="#7-ARM-Mac-运行-x86-架构镜像" class="headerlink" title="7. ARM Mac 运行 x86 架构镜像"></a>7. ARM Mac 运行 x86 架构镜像</h3><p>在搭载 Apple Silicon 的 Mac 上运行 x86 架构的 Docker 镜像：</p><ol><li><p>使用 Colima（推荐）：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Colima</span></span><br><span class="line">brew install colima</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动支持 x86_64 的虚拟机</span></span><br><span class="line">colima start --<span class="built_in">arch</span> x86_64 --memory 4 --disk 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证架构</span></span><br><span class="line">docker info | grep <span class="string">"Architecture"</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>使用 Docker Desktop：</p><ul><li>在设置中启用 “Use Rosetta for x86/amd64 emulation on Apple Silicon”</li></ul></li></ol><h3 id="8-Colima-详细介绍"><a href="#8-Colima-详细介绍" class="headerlink" title="8. Colima 详细介绍"></a>8. Colima 详细介绍</h3><p>Colima 是一个轻量级的容器运行时环境：</p><ul><li><p>特点：</p><ul><li>开源免费</li><li>资源占用低</li><li>支持 x86_64 模拟</li><li>支持 Kubernetes</li><li>命令行友好</li></ul></li><li><p>基本操作：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动 Colima</span></span><br><span class="line">colima start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止 Colima</span></span><br><span class="line">colima stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 Colima 实例</span></span><br><span class="line">colima delete</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">colima status</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="9-最佳实践建议"><a href="#9-最佳实践建议" class="headerlink" title="9. 最佳实践建议"></a>9. 最佳实践建议</h3><ol><li>优先使用多架构镜像</li><li>在构建时就考虑多架构支持</li><li>使用 BuildKit 和 buildx 进行多架构构建</li><li>合理使用 QEMU 模拟器</li><li>在生产环境中尽量使用原生架构</li></ol><h3 id="10-常见问题排查"><a href="#10-常见问题排查" class="headerlink" title="10. 常见问题排查"></a>10. 常见问题排查</h3><ol><li>架构不匹配错误：<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">standard_init_linux.go:228: exec user process caused: exec format error</span><br></pre></td></tr></tbody></table></figure>解决方案：</li></ol><ul><li>确认镜像架构</li><li>使用正确架构的镜像</li><li>启用架构模拟</li></ul><ol start="2"><li>性能问题：</li></ol><ul><li>模拟运行会带来性能损耗</li><li>建议使用原生架构镜像</li><li>必要时增加资源配额</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.docker.com/build/building/multi-platform/">Docker 官方文档</a></li><li><a href="https://github.com/abiosoft/colima">Colima GitHub</a></li><li><a href="https://docs.docker.com/build/buildkit/">BuildKit 文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Docker-架构基础&quot;&gt;&lt;a href=&quot;#Docker-架构基础&quot; class=&quot;headerlink&quot; title=&quot;Docker 架构基础&quot;&gt;&lt;/a&gt;Docker 架构基础&lt;/h2&gt;&lt;h3 id=&quot;1-x86架构的Docker镜像可以运行在arm架构的机器</summary>
      
    
    
    
    <category term="DevOps" scheme="https://nickcodejourney.github.io/categories/DevOps/"/>
    
    
    <category term="docker" scheme="https://nickcodejourney.github.io/tags/docker/"/>
    
    <category term="架构" scheme="https://nickcodejourney.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="x86" scheme="https://nickcodejourney.github.io/tags/x86/"/>
    
    <category term="arm" scheme="https://nickcodejourney.github.io/tags/arm/"/>
    
    <category term="DevOps" scheme="https://nickcodejourney.github.io/tags/DevOps/"/>
    
    <category term="colima" scheme="https://nickcodejourney.github.io/tags/colima/"/>
    
  </entry>
  
  <entry>
    <title>JVM大厂面试真题</title>
    <link href="https://nickcodejourney.github.io/2024/12/17/JVM%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/"/>
    <id>https://nickcodejourney.github.io/2024/12/17/JVM%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/</id>
    <published>2024-12-17T05:13:17.493Z</published>
    <updated>2024-12-17T05:13:17.493Z</updated>
    
    <content type="html"><![CDATA[<p>对于JVM面试，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。</p><h1 id="1、字节码篇"><a href="#1、字节码篇" class="headerlink" title="1、字节码篇"></a>1、字节码篇</h1><ul><li><p>什么是Java虚拟机（墨迹天气）</p></li><li><p>JVM的组成（凡预科技、杭州比智公司）</p></li><li><p>JVM的组成（字节跳动）</p></li><li><p>int a = 1;JVM如何取得a的值（圆通）</p></li><li><p>什么是Java虚拟机(JVM)，为什么要使用？（JVM = Japanese Vedio’s Man ）（阿里）</p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虚拟机：指以软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的完整计算机系统 ，是物理机的软件实现。</span><br><span class="line">常用的虚拟机有VMWare，Visual Box，Java Virtual Machine（Java虚拟机，简称JVM）</span><br></pre></td></tr></tbody></table></figure><ul><li>说说Java虚拟机的生命周期及体系结构。（阿里）</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚拟机的启动</span><br><span class="line"></span><br><span class="line">Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现指定的。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">虚拟机的退出,有如下的几种情况：</span><br><span class="line"></span><br><span class="line">① 某线程调用Runtime类或System类的exit方法，或 Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。</span><br><span class="line"></span><br><span class="line">② 程序正常执行结束</span><br><span class="line"></span><br><span class="line">③ 程序在执行过程中遇到了异常或错误而异常终止</span><br><span class="line"></span><br><span class="line">④ 由于操作系统出现错误而导致Java虚拟机进程终止</span><br></pre></td></tr></tbody></table></figure><ul><li>类文件结构有几个部分？（百度）</li><li>知道字节码吗？字节码都有哪些？Integer x = 5;int y = 5;比较 x == y 都经过哪些步骤？（百度）</li><li>Java中的参数传递时传值呢？还是传引用？ (阿里)</li><li>Java中有没有指针的概念？ (阿里)</li><li>为什么不把基本类型放堆中呢？ (阿里)</li><li>Java虚拟机中，数据类型可以分为哪几类？ (阿里)</li></ul><h1 id="2、类的加载篇"><a href="#2、类的加载篇" class="headerlink" title="2、类的加载篇"></a>2、类的加载篇</h1><ul><li><p>双亲委派好处有哪些？（亚信）</p></li><li><p>JVM底层怎么加载class文件的？（蚂蚁金服）</p></li><li><p>基本数据类型在JVM中的存储位置？（龙湖地产）</p></li><li><p>Java 类加载过程?（苏宁）</p></li><li><p>类加载器双亲委派模型机制？（苏宁）</p></li><li><p>什么是类加载器，类加载器有哪些?（苏宁）</p></li><li><p>描述一下 JVM 加载 Class 文件的原理机制?（国美）</p></li><li><p>什么是tomcat类加载机制？（猎聘）</p></li><li><p>简单说说你了解的类加载器（拼多多）</p></li><li><p>可以打破双亲委派么，怎么打破。（拼多多）</p></li><li><p>深入分析ClassLoader（蚂蚁金服）</p></li><li><p>双亲委派机制 （蚂蚁金服）</p></li><li><p>描述一下 JVM 加载 Class 文件的原理机制? （蚂蚁金服）</p></li><li><p>类加载器的双亲委派模型是什么？ （蚂蚁金服）</p></li><li><p>一面：类加载过程 （蚂蚁金服）</p></li><li><p>一面：双亲委派机制及使用原因 （蚂蚁金服）</p></li><li><p>类加载的时机 （百度）</p></li><li><p>Java 类加载过程? （百度）</p></li><li><p>类加载器都有哪些？（百度） </p></li><li><p>简述 Java 类加载机制?（百度）</p></li><li><p>手写一个类加载器Demo （百度）</p></li><li><p>Class的forName(“Java.lang.String”)和Class的getClassLoader()的loadClass(“Java.lang.String”)有什么区别？ （百度）</p></li><li><p>JVM中类加载机制，类加载过程，什么是双亲委派模型？ （腾讯）</p></li><li><p>类加载器有哪些？ （腾讯）</p></li><li><p>双亲委派模型介绍一下 （小米）</p></li><li><p>JVM类加载机制 （滴滴）</p></li><li><p>一面：讲一下双亲委派模型，以及其优点 （滴滴）</p></li><li><p>什么是类加载器，类加载器有哪些？（字节跳动）</p></li><li><p>Java类加载过程 （美团）</p></li><li><p>描述一下JVM加载class文件的原理机制 （美团）</p></li><li><p>什么是类的加载？ （京东）</p></li><li><p>哪些情况会触发类的加载？ （京东）</p></li><li><p>讲一下JVM加载一个类的过程 （京东）</p></li><li><p>JVM的类加载机制是什么？ （京东）</p></li><li><p>类加载器的双亲委派模型是什么？ （京东）</p></li><li><p>双亲委派机制可以打破吗？为什么 （京东）</p></li></ul><h1 id="3、内存篇"><a href="#3、内存篇" class="headerlink" title="3、内存篇"></a>3、内存篇</h1><h2 id="3-1-开头内容"><a href="#3-1-开头内容" class="headerlink" title="3.1 开头内容"></a>3.1 开头内容</h2><ul><li><p>JVM的内存结构，及各个结构的内容。（vivo）</p></li><li><p>详细介绍一下内存结构（墨迹天气）</p></li><li><p>JVM有那些组成，堆，栈各放了什么东西？（搜狐、万达集团）</p></li><li><p>JVM的内存模型，线程独有的放在哪里？哪些是线程共享的？哪些是线程独占的？（万达集团）</p></li><li><p>JVM内存模型有哪些？（龙湖地产）</p></li><li><p>Java虚拟机中内存划分为那些区域（高德地图）</p></li><li><p>JVM内存模型（中国计算机研究院、亚信）</p></li><li><p>讲一下为什么JVM要分为堆、方法区等？原理是什么？（小米、搜狐）</p></li><li><p>JVM的内存模型，线程独有的放在哪里？哪些是线程共享的？哪些是线程独占的？（菜鸟）</p></li><li><p>简单说一下JVM内存结构（浪潮）</p></li><li><p>JVM内存结构（花旗银行）</p></li><li><p>JVM 内存分哪几个区，每个区的作用是什么?（唯品会）</p></li><li><p>详解JVM内存模型（360）</p></li><li><p>JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。（拼多多）</p></li><li><p>说一下JVM内存模型吧，有哪些区？分别干什么的？ (百度)</p></li><li><p>JVM的内存结构划分是什么样子的？ (支付宝)</p></li><li><p>JVM 内存分哪几个区，每个区的作用是什么? (蚂蚁金服)</p></li><li><p>Java虚拟机内存模型能说说吗？ (蚂蚁金服)</p></li><li><p>JVM内存分布/内存结构？ (蚂蚁金服)</p></li><li><p>讲讲JVM分区 (携程)</p></li><li><p>一面：讲一下JVM内存布局 (滴滴)</p></li><li><p>Java的内存分区 (字节跳动)</p></li><li><p>讲讲JVM运行时数据库区 (字节跳动)</p></li><li><p>JVM内存模型以及分区，需要详细到每个区放什么。 (天猫)</p></li><li><p>JVM 内存分哪几个区，每个区的作用是什么? (拼多多)</p></li><li><p>JVM的内存布局以及垃圾回收原理及过程讲一下 (京东)</p></li></ul><h2 id="3-2-程序计数器"><a href="#3-2-程序计数器" class="headerlink" title="3.2 程序计数器"></a>3.2 程序计数器</h2><ul><li>JVM计数器如何记数（京东-物流）</li></ul><h2 id="3-3-栈"><a href="#3-3-栈" class="headerlink" title="3.3 栈"></a>3.3 栈</h2><ul><li><p>堆和栈的区别、谁的性能更高（艾绒软件）</p></li><li><p>栈是如何运行的（OPPO）</p></li><li><p>JVM有哪些组成，堆，栈各放了什么东西。（新浪）</p></li><li><p>Java 中堆和栈有什么区别？（国美）</p></li><li><p>什么情况下会发生栈内存溢出。（360）</p></li><li><p>栈和堆的区别？（蚂蚁金服）</p></li><li><p>什么情况下会发生栈内存溢出。 (京东)</p></li><li><p>Java中，栈的大小通过什么参数来设置？ (阿里)</p></li><li><p>怎么理解栈、堆？堆中存什么？栈中存什么？ (阿里)</p></li><li><p>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？ (阿里)</p></li><li><p>说一下什么情况发生栈溢出 (滴滴)</p></li></ul><h2 id="3-4-堆与MinorGC-MajorGC"><a href="#3-4-堆与MinorGC-MajorGC" class="headerlink" title="3.4 堆与MinorGC MajorGC"></a>3.4 堆与MinorGC MajorGC</h2><ul><li><p>什么时候对象会进入老年代？（顺丰）</p></li><li><p>初始堆大小和最大堆大小一样，问这样有什么好处？（亚信）</p></li><li><p>老年代的垃圾回收机制什么时候触发，自动触发的阈值是多少（蚂蚁金服）</p></li><li><p>新生代的垃圾回收什么时候触发（蚂蚁金服）</p></li><li><p>堆里面的分区：Eden，survival （from+ to），老年代，各自的特点。（京东-物流）</p></li><li><p>Minor GC 与 Full GC 分别在什么时候发生？（腾讯）</p></li><li><p>简述 Java 内存分配与回收策略以及 Minor GC 和Major GC（国美）</p></li><li><p>Java 堆的结构是什么样子的？（猎聘）</p></li><li><p>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor（字节跳动）</p></li><li><p>什么时候发生Full GC（58）</p></li><li><p>计算下多长时间触发一次Minor GC（蚂蚁金服）</p></li><li><p>堆的结构？为什么两个survivor区？ (蚂蚁金服)</p></li><li><p>Eden和Survior的比例分配 (蚂蚁金服)</p></li><li><p>JVM内存分区，为什么要有新生代和老年代 (小米)</p></li><li><p>JVM的内存结构，Eden和Survivor比例。 (京东)</p></li><li><p>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。 (京东)</p></li><li><p>JVM内存分区，为什么要有新生代和老年代？ (美团)</p></li><li><p>JVM的内存结构，Eden和Survivor比例。 (京东)</p></li><li><p>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。 (京东)</p></li><li><p>堆大小通过什么参数设置？ (阿里)</p></li><li><p>简述 Java 内存分配与回收策略以及 Minor GC 和Major GC (百度)</p></li><li><p>JVM垃圾回收机制，何时触发Minor GC等操作 (蚂蚁金服)</p></li><li><p>JVM的一次完整的GC流程（从ygc到fgc)是怎样的(蚂蚁金服)</p></li><li><p>JVM中最大堆大小有没有限制？ (阿里)</p></li><li><p>描述JVM中一次full gc过程 (腾讯)</p></li></ul><h2 id="3-5-对象分配"><a href="#3-5-对象分配" class="headerlink" title="3.5 对象分配"></a>3.5 对象分配</h2><ul><li><p>什么时候对象会进入老年代？（渣打银行）</p></li><li><p>什么是空间分配担保策略？（渣打银行）</p></li><li><p>什么是空间分配担保策略？（腾讯、百度）</p></li><li><p>什么是空间分配担保策略？（顺丰）</p></li><li><p>问什么幸存者区15次进入老年区，懂原理吗？（58）</p></li><li><p>JVM的伊甸园区，from区，to区的比例是否可调？（花旗银行）</p></li><li><p>JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代（字节跳动）</p></li><li><p>什么时候对象会进入老年代？ (字节跳动)</p></li><li><p>对象在堆内存创建的生命周期 (蚂蚁金服)</p></li><li><p>重点讲讲对象如何晋升到老年代，几种主要的JVM参数 (蚂蚁金服)</p></li><li><p>新生代和老年代的内存回收策略 (蚂蚁金服)</p></li><li><p>什么时候对象可以被收回？ (蚂蚁金服)</p></li></ul><h2 id="3-6-方法区"><a href="#3-6-方法区" class="headerlink" title="3.6 方法区"></a>3.6 方法区</h2><ul><li><p>JVM的永久代中会发生垃圾回收么?（腾讯）</p></li><li><p>JVM的永久代中会发生垃圾回收吗？ (美团)</p></li></ul><h2 id="3-7-总结"><a href="#3-7-总结" class="headerlink" title="3.7 总结"></a>3.7 总结</h2><ul><li><p>讲一下为什么JVM要分为堆、方法区等？原理是什么？（UC、智联）</p></li><li><p>JVM的分区了解吗，内存溢出发生在哪个位置 （亚信、BOSS）</p></li><li><p>简述各个版本内存区域的变化？（猎聘）</p></li><li><p>Java8的内存分代改进 (蚂蚁金服)</p></li><li><p>JVM的内存模型，Java8做了什么修改 (天猫)</p></li><li><p>OOM的错误，StackOverFlow错误，permgen space的错误 (蚂蚁金服)</p></li></ul><h2 id="3-8-String"><a href="#3-8-String" class="headerlink" title="3.8 String"></a>3.8 String</h2><ul><li>new string()是放在哪里，还放在哪里？（搜狐、万达集团）</li></ul><h1 id="4、对象内存布局篇"><a href="#4、对象内存布局篇" class="headerlink" title="4、对象内存布局篇"></a>4、对象内存布局篇</h1><ul><li><p>new对象流程？（龙湖地产）</p></li><li><p>对象创建方法，对象的内存分配，对象的访问定位。（360安全）</p></li><li><p>Java对象头里有什么 (蚂蚁金服)</p></li><li><p>对象在JVM中是怎么存储的？ (美团)</p></li><li><p>对象头信息里面有哪些东西？ (美团)</p></li><li><p>二面：Java对象头里有什么 (蚂蚁金服)</p></li></ul><h1 id="5、GC篇"><a href="#5、GC篇" class="headerlink" title="5、GC篇"></a>5、GC篇</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ul><li><p>讲讲JVM的gc (携程)</p></li><li><p>GC是什么？为什么要有GC？ (蚂蚁金服)</p></li><li><p>什么情况下触发垃圾回收？ (阿里)</p></li></ul><h2 id="5-2-垃圾回收器"><a href="#5-2-垃圾回收器" class="headerlink" title="5.2 垃圾回收器"></a>5.2 垃圾回收器</h2><ul><li><p>常见的垃圾回收器算法有哪些，各有什么优劣？（网易）</p></li><li><p>常见的垃圾回收器算法有哪些，各有什么优劣？（阿里-天猫、UC）</p></li><li><p>有哪些垃圾回收方法，jdk8的垃圾收集器是什么？（搜狐、万达集团）</p></li><li><p>G1原理。（亚信）</p></li><li><p>几种垃圾回收器（亚信）</p></li><li><p>垃圾回收器有哪些？都有哪些算法来实现？项目中用的垃圾回收器是什么？（平安）</p></li><li><p>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？（平安）</p></li><li><p>你知道那些垃圾回收器（高德地图）</p></li><li><p>有些垃圾方法，8的垃圾收集器是什么。（新浪）</p></li><li><p>GC 收集器有哪些？CMS 收集器与 G1 收集器的特点。</p></li><li><p>请问吞吐量的优化和响应优先的垃圾收集器是如何选择的呢？（滴滴）</p></li><li><p>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。（拼多多）</p></li><li><p>CMS 收集器与 G1 收集器的特点。 (蚂蚁金服)</p></li><li><p>G1回收器讲下回收过程 (蚂蚁金服)</p></li><li><p>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下cms和g1，包括原理，流程，优缺点 (蚂蚁金服)</p></li><li><p>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？ (天猫)</p></li><li><p>讲一下CMS垃圾收集器垃圾回收的流程，以及CMS的缺点 (抖音)</p></li><li><p>Java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的 (滴滴)</p></li><li><p>说几个垃圾回收器，cms回收器有哪几个过程，停顿几次，会不会产生内存碎片。老年代产生内存碎片会有什么问题。 (小米)</p></li><li><p>JVM有哪三种垃圾回收器？ (阿里)</p></li><li><p>吞吐量优先选择什么垃圾回收器？响应时间优先呢？ (阿里)</p></li><li><p>常见的垃圾回收器算法有哪些，各有什么优劣？ (字节跳动)</p></li><li><p>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。(字节跳动)</p></li><li><p>CMS回收停顿了几次，为什么要停顿两次。(字节跳动)</p></li><li><p>CMS过程是怎样的？内部使用什么算法做垃圾回收？ (美团)</p></li><li><p>g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择 (携程)</p></li></ul><h2 id="5-3-垃圾回收算法"><a href="#5-3-垃圾回收算法" class="headerlink" title="5.3 垃圾回收算法"></a>5.3 垃圾回收算法</h2><ul><li><p>什么时候对象可以被收回？（阿里-闲鱼）</p></li><li><p>什么时候对象可以被收回？（拼多多）</p></li><li><p>GC算法都有哪些？他们之间的区别是什么？（菜鸟）</p></li><li><p>JVM的常用的GC算法（高得地图）</p></li><li><p>JVM的垃圾回收为什么采用分代GC。跟语言有关系吗？（阿里-钉钉）</p></li><li><p>分代的意义说一下 （阿里-钉钉）</p></li><li><p>而全GC时间较长 分代GC可以大大降低GC时间而且也可以保证heap不会过快增长（墨迹天气）</p></li><li><p>GC垃圾回收机制算法（数信互融科技发展有限公司）</p></li><li><p>GC的算法，复制算法和标记清除的优缺点？（迪原创新）</p></li><li><p>常用的GC算法，如何确定哪些是要被清除的哪些是不能被清除（网易邮箱、美团）</p></li><li><p>垃圾回收机制的几种回收算法（亚信）</p></li><li><p>GC算法都有哪些？他们之间的区别是什么？各自的适用场景？（B站）</p></li><li><p>GC分代算法（花旗银行）</p></li><li><p>新生代的垃圾回收什么时候触发（花旗银行）</p></li><li><p>老年代的垃圾回收机制什么时候触发，自动触发的阈值是多少（花旗银行）</p></li><li><p>GC 的两种判定方法：（360安全）</p></li><li><p>GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？（腾讯）</p></li><li><p>如何判断一个对象是否存活?（唯品会）</p></li><li><p>Java 中垃圾收集的方法有哪些?（苏宁）</p></li><li><p>你是用什么方法判断对象是否死亡？（滴滴）</p></li><li><p>说一下GC算法，分代回收说下 (百度)</p></li><li><p>垃圾收集策略和算法 (百度)</p></li><li><p>说一下gc算法，分代回收说下 (百度)</p></li><li><p>说一下gc算法，分代回收说下 (百度)</p></li><li><p>JVM有哪些回收算法，对应的收集器有哪些？ (蚂蚁金服)</p></li><li><p>如何判断一个对象是否存活？ (蚂蚁金服)</p></li><li><p>JVM GC算法有哪些，目前的JDK版本采用什么回收算法 (蚂蚁金服)</p></li><li><p>垃圾回收算法的实现原理。 (京东)</p></li><li><p>JVM场景问题， 标记清除多次后老年代产生内存碎片，引起full gc，接下来可能发生什么问题。 (小米)</p></li><li><p>Java怎么进行垃圾回收的？什么对象会进老年代？ 垃圾回收算法有哪些？为什么新生代使用复制算法？ (京东)</p></li><li><p>讲一下JVM中如何判断对象的生死？ (京东)</p></li><li><p>如何选择合适的垃圾收集算法？ (阿里)</p></li><li><p>讲一讲垃圾回收算法。 (阿里)</p></li><li><p>JVM有哪些回收算法，对应的收集器有哪些？ (拼多多)</p></li><li><p>讲讲你知道的垃圾回收算法 (字节跳动)</p></li><li><p>Java对象的回收方式，回收算法。 (字节跳动)</p></li><li><p>JVM垃圾收集算法与收集器有哪些？ (京东)</p></li><li><p>JVM场景问题， 标记清除多次后老年代产生内存碎片，引起full gc，接下来可能发生什么问题？ (美团)</p></li><li><p>分代垃圾回收过程？ (美团)</p></li><li><p>GC如何分代的？各代用什么算法回收？ (美团)</p></li></ul><h2 id="5-4-其-它"><a href="#5-4-其-它" class="headerlink" title="5.4 其 它"></a>5.4 其 它</h2><ul><li><p>GC回收的是哪部分的垃圾？（vivo）</p></li><li><p>什么是内存泄漏和什么是内存溢出（陌陌）</p></li><li><p>Java存在内存泄漏吗，内存泄漏的场景有哪些，如何避免（百度）</p></li><li><p>SafePoint 是什么（360安全）</p></li><li><p>Java 中会存在内存泄漏吗，简述一下？（猎聘）</p></li><li><p>垃圾回收的优点和原理，并考虑 2 种回收机制？基本原理是什么？（瓜子）</p></li><li><p>什么是分布式垃圾回收（DGC）？它是如何工作的？（瓜子）</p></li><li><p>强引用、软引用、弱引用、虚引用的区别？（字节跳动）</p></li><li><p>垃圾回收的优点和原理。 (蚂蚁金服)</p></li><li><p>如何解决内存碎片的问题？ (阿里)</p></li><li><p>垃圾回收机制等 (支付宝)</p></li><li><p>Java GC机制？GC Roots有哪些？ (拼多多)</p></li><li><p>JVM怎样判断一个对象是否可回收，怎样的对象才能作为GC root (腾讯)</p></li><li><p>什么是Full GC？GC? major GC? stop the world (腾讯)</p></li><li><p>System.gc()和RunTime.gc()会做什么事情？ (字节跳动)</p></li><li><p>Java GC机制？GC Roots有哪些？ (字节跳动)</p></li><li><p>哪些部分可以作为GC Root？ (字节跳动)</p></li><li><p>Java GC机制？GC Roots有哪些？ (抖音)</p></li><li><p>Java GC机制？GC Roots有哪些？ (京东)</p></li><li><p>GC是什么？为什么要有GC？ (美团)</p></li><li><p>简述Java垃圾回收机制 (美团)</p></li><li><p>如何判断一个对象是否存活？（或者GC对象的判定方法）  (美团)</p></li><li><p>垃圾回收的优点和原理。(美团)</p></li><li><p>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？(美团)</p></li><li><p>有什么办法主动通知虚拟机进行垃圾回收？  (美团)</p></li><li><p>GC root如何确定，哪些对象可以作为GC Root? (美团)</p></li><li><p>你开发中使用过WeakHashMap吗？(京东)</p></li></ul><h1 id="6、执行引擎篇"><a href="#6、执行引擎篇" class="headerlink" title="6、执行引擎篇"></a>6、执行引擎篇</h1><ul><li><p>你是怎么指定JVM启动模式？（字节跳动）</p></li><li><p>那你知道-server和-client的区别吗？（美图）</p></li></ul><h1 id="7、调优工具篇"><a href="#7、调优工具篇" class="headerlink" title="7、调优工具篇"></a>7、调优工具篇</h1><ul><li><p>怎么获取 Java 程序使用的内存？堆使用的百分比？（国美）</p></li><li><p>讲讲你理解的性能评价及测试指标？（瓜子）</p></li><li><p>JVM的进程有哪些线程启动，有了解吗？（神州租车）</p></li><li><p>你使用过Java虚拟机性能监控和故障处理工具吗？（美图）</p></li><li><p>说说你知道的几种主要的JVM参数（京东）</p></li><li><p>怎么打出线程栈信息。（字节跳动）</p></li><li><p>JVM的参数，你知道的说一下 (百度)</p></li></ul><h1 id="8、调优篇"><a href="#8、调优篇" class="headerlink" title="8、调优篇"></a>8、调优篇</h1><ul><li><p>JVM调优调的哪些参数？在哪里写这些参数？ （亚信）</p></li><li><p>说到内存泄漏，问有没有碰到，内存泄漏怎么解决？（拼多多）</p></li><li><p>常用的性能优化方式有哪些？（百度金融）</p></li><li><p>内存泄漏是怎么造成的？（拼多多、字节跳动）</p></li><li><p>虚拟机如何调优？（顺丰）</p></li><li><p>内存调优怎么调？有几种方式？参数都有什么？（顺丰）</p></li><li><p>栈溢出导致的原因？如何解决？（搜狐）</p></li><li><p>JVM调优策略 （杭州鲁尔物联科技有限公司、燕梭金融、汇博云通）</p></li><li><p>JVM调优调的哪些参数？问这样有什么好处？在哪里写这些参数（浪潮）</p></li><li><p>几种常用的内存调试工具你知道哪些？（搜狐）</p></li><li><p>如何优化减少Full GC？（阿里-闲鱼）</p></li><li><p>当出现了内存溢出，你怎么排错。 (京东)</p></li><li><p>有实际的JVM性能调优案例吗？重点需要关注哪些核心参数？ (滴滴)</p></li><li><p>OOM说一下？怎么排查？哪些会导致OOM? OOM出现在什么时候 (腾讯)</p></li><li><p>内存泄漏与内存溢出的区别 (字节跳动)</p></li><li><p>Java存在内存溢出的现象吗(字节跳动)</p></li><li><p>Java中会存在内存泄漏吗，请简单描述。  (美团) </p></li><li><p>JVM性能调优都做了什么？(支付宝)</p></li><li><p>有做过JVM内存优化吗？ (小米)</p></li><li><p>从SQL、JVM、架构、数据库四个方面讲讲优化思路 (小米)</p></li><li><p>JVM的编译优化 (蚂蚁金服)</p></li><li><p>JVM性能调优都做了什么 (蚂蚁金服)</p></li><li><p>JVM诊断调优工具用过哪些？ (蚂蚁金服)</p></li><li><p>JVM怎样调优，堆内存栈空间设置多少合适.. (蚂蚁金服)</p></li><li><p>JVM相关的分析工具使用过的有哪些？具体的性能调优步骤如何 (蚂蚁金服)</p></li><li><p>如何进行JVM调优？有哪些方法？ (阿里)</p></li><li><p>如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？ (阿里)</p></li><li><p>JVM如何调优、参数怎么调？ (字节跳动)</p></li><li><p>从SQL、JVM、架构、数据库四个方面讲讲优化思路 (拼多多)</p></li><li><p>JVM诊断调优工具用过哪些？ (京东)</p></li><li><p>每秒几十万并发的秒杀系统为什么会频繁发生GC？ (京东)</p></li><li><p>日均百万级交易系统如何优化JVM？ (京东)</p></li><li><p>线上生产系统OOM如何监控及定位与解决？ (京东)</p></li><li><p>高并发系统如何基于G1垃圾回收器优化性能？ (京东)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于JVM面试，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。&lt;/p&gt;
&lt;h1 id=&quot;1、字节码篇&quot;&gt;&lt;a href=&quot;#1、字节码篇&quot; class=&quot;headerlink&quot; title=&quot;1、字节码篇</summary>
      
    
    
    
    <category term="面试题" scheme="https://nickcodejourney.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="jvm" scheme="https://nickcodejourney.github.io/tags/jvm/"/>
    
    <category term="java" scheme="https://nickcodejourney.github.io/tags/java/"/>
    
    <category term="基础知识" scheme="https://nickcodejourney.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="面试" scheme="https://nickcodejourney.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试大纲</title>
    <link href="https://nickcodejourney.github.io/2023/11/29/%E9%9D%A2%E8%AF%95%E5%A4%A7%E7%BA%B2/"/>
    <id>https://nickcodejourney.github.io/2023/11/29/%E9%9D%A2%E8%AF%95%E5%A4%A7%E7%BA%B2/</id>
    <published>2023-11-29T06:12:21.000Z</published>
    <updated>2024-12-17T05:13:17.502Z</updated>
    
    <content type="html"><![CDATA[<p>1 数据结构与算法</p><p>2 jvm</p><p>3 多线程</p><p>4 数据库（mysql）</p><p>5 redis</p><p>6 mq ,kafka</p><p>7 es</p><p>8 spring / spring boot</p><p>9 spring cloud</p><p>10 设计模式</p><p>11 系统设计</p><p>12 分布式</p><p>13 项目经验</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1 数据结构与算法&lt;/p&gt;
&lt;p&gt;2 jvm&lt;/p&gt;
&lt;p&gt;3 多线程&lt;/p&gt;
&lt;p&gt;4 数据库（mysql）&lt;/p&gt;
&lt;p&gt;5 redis&lt;/p&gt;
&lt;p&gt;6 mq ,kafka&lt;/p&gt;
&lt;p&gt;7 es&lt;/p&gt;
&lt;p&gt;8 spring / spring boot&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="面试" scheme="https://nickcodejourney.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://nickcodejourney.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="大纲" scheme="https://nickcodejourney.github.io/tags/%E5%A4%A7%E7%BA%B2/"/>
    
  </entry>
  
  <entry>
    <title>杭州之旅</title>
    <link href="https://nickcodejourney.github.io/2023/11/28/%E6%9D%AD%E5%B7%9E%E4%B9%8B%E6%97%85/"/>
    <id>https://nickcodejourney.github.io/2023/11/28/%E6%9D%AD%E5%B7%9E%E4%B9%8B%E6%97%85/</id>
    <published>2023-11-28T05:11:55.000Z</published>
    <updated>2024-12-17T06:41:10.255Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/11/28/%E6%9D%AD%E5%B7%9E%E4%B9%8B%E6%97%85/fengmian.jpeg" alt="fengmian.jpeg"><br><img src="/2023/11/28/%E6%9D%AD%E5%B7%9E%E4%B9%8B%E6%97%85/ronghaoli.jpeg" alt="ronghaoli.jpeg"><br><img src="/2023/11/28/%E6%9D%AD%E5%B7%9E%E4%B9%8B%E6%97%85/eson.jpeg" alt="eson.jpeg"><br><img src="/2023/11/28/%E6%9D%AD%E5%B7%9E%E4%B9%8B%E6%97%85/night.jpeg" alt="night.jpeg"><br><img src="/2023/11/28/%E6%9D%AD%E5%B7%9E%E4%B9%8B%E6%97%85/flynight.jpg" alt="flynight.jpg"><br><img src="/2023/11/28/%E6%9D%AD%E5%B7%9E%E4%B9%8B%E6%97%85/oragin.jpeg" alt="oragin.jpeg"><br><img src="/2023/11/28/%E6%9D%AD%E5%B7%9E%E4%B9%8B%E6%97%85/flawor.jpeg" alt="flawor.jpeg"><br><img src="/2023/11/28/%E6%9D%AD%E5%B7%9E%E4%B9%8B%E6%97%85/gj.jpeg" alt="gj.jpeg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/11/28/%E6%9D%AD%E5%B7%9E%E4%B9%8B%E6%97%85/fengmian.jpeg&quot; alt=&quot;fengmian.jpeg&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2023/11/28/%E6%9D%AD%E5%B7%9</summary>
      
    
    
    
    <category term="生活" scheme="https://nickcodejourney.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://nickcodejourney.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="旅行" scheme="https://nickcodejourney.github.io/tags/%E6%97%85%E8%A1%8C/"/>
    
  </entry>
  
</feed>
